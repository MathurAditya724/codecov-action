import type {
  AggregatedTestResults,
  TestComparison,
} from "../types/test-results.js";
import type {
  AggregatedCoverageResults,
  CoverageComparison,
} from "../types/coverage.js";

export class PRCommentFormatter {
  /**
   * Format test results and coverage as a markdown comment for PRs
   */
  formatComment(
    testResults?: AggregatedTestResults,
    coverageResults?: AggregatedCoverageResults
  ): string {
    const lines: string[] = [];

    // Main header
    lines.push("## Codecov Action Results ğŸ“Š");
    lines.push("");

    // Add test results section
    if (testResults) {
      this.addTestResultsSection(lines, testResults);
    }

    // Add coverage section
    if (coverageResults) {
      this.addCoverageSection(lines, coverageResults);
    }

    // Footer
    lines.push("---");
    lines.push("*Generated by Codecov Action*");

    return lines.join("\n");
  }

  /**
   * Format only test results as a markdown comment for PRs (backward compatibility)
   */
  formatTestComment(results: AggregatedTestResults): string {
    const lines: string[] = [];

    // Header
    lines.push("## Test Results ğŸ§ª");
    lines.push("");

    // Summary line with emoji indicators
    const passEmoji = results.passedTests > 0 ? "âœ…" : "";
    const failEmoji = results.failedTests > 0 ? "âŒ" : "";
    const skipEmoji = results.skippedTests > 0 ? "â­ï¸" : "";

    const summaryParts: string[] = [];

    if (passEmoji) {
      summaryParts.push(`${passEmoji} **${results.passedTests} passed**`);
    }
    if (failEmoji) {
      summaryParts.push(`${failEmoji} **${results.failedTests} failed**`);
    }
    if (skipEmoji) {
      summaryParts.push(`${skipEmoji} **${results.skippedTests} skipped**`);
    }

    // Add total and pass rate
    summaryParts.push(`**Total: ${results.totalTests}**`);
    summaryParts.push(`**Pass Rate: ${results.passRate}%**`);

    lines.push(summaryParts.join(" | "));
    lines.push("");

    // Execution time
    lines.push(`â±ï¸ **Execution Time:** ${this.formatTime(results.totalTime)}`);
    lines.push("");

    // Add comparison section if available
    if (results.comparison) {
      this.addComparisonSection(lines, results.comparison);
    }

    // Show failed tests if any
    if (results.failedTests > 0 && results.failedTestCases.length > 0) {
      lines.push("### âŒ Failed Tests");
      lines.push("");

      for (const { suiteName, testCase } of results.failedTestCases) {
        // Test header
        lines.push(`#### \`${testCase.name}\``);
        lines.push(`**File:** \`${testCase.classname}\``);

        if (suiteName && suiteName !== testCase.classname) {
          lines.push(`**Suite:** \`${suiteName}\``);
        }

        if (testCase.failure) {
          lines.push(`**Error:** ${testCase.failure.message}`);
          lines.push("");

          // Stack trace in collapsible details
          if (testCase.failure.content) {
            lines.push("<details>");
            lines.push("<summary>Stack Trace</summary>");
            lines.push("");
            lines.push("```");
            lines.push(testCase.failure.content.trim());
            lines.push("```");
            lines.push("");
            lines.push("</details>");
            lines.push("");
          }
        }
      }
    } else if (results.failedTests === 0) {
      // Success message
      lines.push("### âœ… All Tests Passed!");
      lines.push("");
      lines.push("Great job! All tests are passing successfully.");
      lines.push("");
    }

    // Footer
    lines.push("---");
    lines.push("*Generated by Codecov Action*");

    return lines.join("\n");
  }

  /**
   * Add test results section to the comment
   */
  private addTestResultsSection(
    lines: string[],
    results: AggregatedTestResults
  ): void {
    lines.push("## Test Results ğŸ§ª");
    lines.push("");

    // Summary line with emoji indicators
    const passEmoji = results.passedTests > 0 ? "âœ…" : "";
    const failEmoji = results.failedTests > 0 ? "âŒ" : "";
    const skipEmoji = results.skippedTests > 0 ? "â­ï¸" : "";

    const summaryParts: string[] = [];

    if (passEmoji) {
      summaryParts.push(`${passEmoji} **${results.passedTests} passed**`);
    }
    if (failEmoji) {
      summaryParts.push(`${failEmoji} **${results.failedTests} failed**`);
    }
    if (skipEmoji) {
      summaryParts.push(`${skipEmoji} **${results.skippedTests} skipped**`);
    }

    // Add total and pass rate
    summaryParts.push(`**Total: ${results.totalTests}**`);
    summaryParts.push(`**Pass Rate: ${results.passRate}%**`);

    lines.push(summaryParts.join(" | "));
    lines.push("");

    // Execution time
    lines.push(`â±ï¸ **Execution Time:** ${this.formatTime(results.totalTime)}`);
    lines.push("");

    // Add comparison section if available
    if (results.comparison) {
      this.addComparisonSection(lines, results.comparison);
    }

    // Show failed tests if any
    if (results.failedTests > 0 && results.failedTestCases.length > 0) {
      lines.push("### âŒ Failed Tests");
      lines.push("");

      for (const { suiteName, testCase } of results.failedTestCases) {
        // Test header
        lines.push(`#### \`${testCase.name}\``);
        lines.push(`**File:** \`${testCase.classname}\``);

        if (suiteName && suiteName !== testCase.classname) {
          lines.push(`**Suite:** \`${suiteName}\``);
        }

        if (testCase.failure) {
          lines.push(`**Error:** ${testCase.failure.message}`);
          lines.push("");

          // Stack trace in collapsible details
          if (testCase.failure.content) {
            lines.push("<details>");
            lines.push("<summary>Stack Trace</summary>");
            lines.push("");
            lines.push("```");
            lines.push(testCase.failure.content.trim());
            lines.push("```");
            lines.push("");
            lines.push("</details>");
            lines.push("");
          }
        }
      }
    } else if (results.failedTests === 0) {
      // Success message
      lines.push("### âœ… All Tests Passed!");
      lines.push("");
      lines.push("Great job! All tests are passing successfully.");
      lines.push("");
    }

    lines.push("");
  }

  /**
   * Add coverage section to the comment (clean, minimal format)
   */
  private addCoverageSection(
    lines: string[],
    results: AggregatedCoverageResults
  ): void {
    lines.push("## Codecov Report");
    lines.push("");

    // Calculate metrics
    const totalMissing = results.totalMisses || 0;
    const coverageChange = results.comparison
      ? this.formatCoverageDelta(results.comparison.deltaLineRate)
      : null;

    // Single line summary
    const parts: string[] = [`Coverage: **${results.lineRate}%**`];
    if (coverageChange) {
      parts[0] += ` (${coverageChange}%)`;
    }
    if (totalMissing > 0) {
      parts.push(`${totalMissing} lines missing`);
    }
    if (results.comparison) {
      const baseRef = results.comparison.baseCommit
        ? `\`${results.comparison.baseCommit.substring(0, 7)}\``
        : "`base`";
      const headRef = results.comparison.headCommit
        ? `\`${results.comparison.headCommit.substring(0, 7)}\``
        : "`head`";
      parts.push(`Comparing ${baseRef} to ${headRef}`);
    }

    lines.push(parts.join(" | "));
    lines.push("");

    // Files with missing lines (all in collapsed section)
    const filesWithMissing = results.files
      .filter((f) => (f.missingLines?.length || 0) > 0 || (f.partialLines?.length || 0) > 0)
      .sort((a, b) => {
        const aMissing = (a.missingLines?.length || 0) + (a.partialLines?.length || 0);
        const bMissing = (b.missingLines?.length || 0) + (b.partialLines?.length || 0);
        return bMissing - aMissing;
      });

    if (filesWithMissing.length > 0) {
      lines.push("<details>");
      lines.push(`<summary>Files with missing lines (${filesWithMissing.length} files)</summary>`);
      lines.push("");
      lines.push("| File | Coverage | Missing |");
      lines.push("|------|----------|---------|");

      for (const file of filesWithMissing) {
        const fileName = this.getFileName(file.path);
        const missingCount = file.missingLines?.length || 0;
        const partialCount = file.partialLines?.length || 0;

        let linesText = "";
        if (missingCount > 0 && partialCount > 0) {
          linesText = `${missingCount} missing, ${partialCount} partial`;
        } else if (missingCount > 0) {
          linesText = `${missingCount} missing`;
        } else if (partialCount > 0) {
          linesText = `${partialCount} partial`;
        }

        lines.push(`| \`${fileName}\` | ${file.lineRate.toFixed(2)}% | ${linesText} |`);
      }

      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Coverage diff (collapsible)
    if (results.comparison) {
      this.addDetailedCoverageDiff(lines, results);
    }

    // Flags section (collapsible)
    if (results.flags && results.flags.length > 0) {
      this.addFlagsSection(lines, results);
    }
  }

  /**
   * Add detailed coverage diff table (collapsible)
   */
  private addDetailedCoverageDiff(
    lines: string[],
    results: AggregatedCoverageResults
  ): void {
    const comparison = results.comparison;
    if (!comparison) return;

    const baseBranch = comparison.baseBranch || "base";

    lines.push("<details>");
    lines.push("<summary>Coverage diff</summary>");
    lines.push("");

    // Clean coverage diff table
    lines.push(`| Metric | ${baseBranch} | PR | +/- |`);
    lines.push("|--------|------|-----|-----|");
    lines.push(
      `| Coverage | ${(results.lineRate - comparison.deltaLineRate).toFixed(2)}% | ${results.lineRate}% | ${this.formatCoverageDelta(comparison.deltaLineRate)}% |`
    );
    lines.push(
      `| Lines | ${comparison.baseLines || 0} | ${comparison.currentLines || 0} | ${this.formatDeltaSimple(comparison.deltaLines || 0)} |`
    );
    lines.push(
      `| Hits | ${comparison.baseHits || 0} | ${comparison.currentHits || 0} | ${this.formatDeltaSimple(comparison.deltaHits || 0)} |`
    );
    lines.push(
      `| Misses | ${comparison.baseMisses || 0} | ${comparison.currentMisses || 0} | ${this.formatDeltaSimple(comparison.deltaMisses || 0)} |`
    );

    // Only add partials row if there are any
    if ((comparison.basePartials || 0) > 0 || (comparison.currentPartials || 0) > 0) {
      lines.push(
        `| Partials | ${comparison.basePartials || 0} | ${comparison.currentPartials || 0} | ${this.formatDeltaSimple(comparison.deltaPartials || 0)} |`
      );
    }

    lines.push("");
    lines.push("</details>");
    lines.push("");
  }

  /**
   * Add flags section (collapsible)
   */
  private addFlagsSection(
    lines: string[],
    results: AggregatedCoverageResults
  ): void {
    if (!results.flags || results.flags.length === 0) return;

    lines.push("<details>");
    lines.push(`<summary>Flags (${results.flags.length})</summary>`);
    lines.push("");

    for (const flag of results.flags) {
      const coverageChange = results.comparison
        ? ` (${this.formatCoverageDelta(results.comparison.deltaLineRate)}%)`
        : "";
      lines.push(`- \`${flag}\`: ${results.lineRate}%${coverageChange}`);
    }
    lines.push("");
    lines.push("</details>");
    lines.push("");
  }

  /**
   * Get just the filename from a path
   */
  private getFileName(path: string): string {
    return path.split("/").pop() || path;
  }

  /**
   * Truncate file name for display
   */
  private truncateFileName(path: string, maxLength: number): string {
    if (path.length <= maxLength) return path;
    return `...${path.slice(-(maxLength - 3))}`;
  }

  /**
   * Format delta value with sign only (no emoji)
   */
  private formatDeltaSimple(delta: number): string {
    if (delta === 0) return "â€”";
    const sign = delta > 0 ? "+" : "";
    return `${sign}${delta}`;
  }

  /**
   * Add coverage comparison section
   */
  private addCoverageComparisonSection(
    lines: string[],
    comparison: CoverageComparison
  ): void {
    lines.push("### ğŸ“Š Coverage Change from Base Branch");
    lines.push("");

    // Improvement or degradation indicator
    if (comparison.improvement) {
      lines.push("#### ğŸ“ˆ Coverage Improved!");
    } else if (
      comparison.deltaLineRate < 0 ||
      comparison.deltaBranchRate < 0
    ) {
      lines.push("#### ğŸ“‰ Coverage Decreased");
    } else {
      lines.push("#### â¡ï¸ Coverage Unchanged");
    }
    lines.push("");

    // Summary table
    lines.push("| Metric | Change |");
    lines.push("|--------|--------|");
    lines.push(
      `| Line Coverage | ${this.formatCoverageDelta(comparison.deltaLineRate)}% |`
    );
    lines.push(
      `| Branch Coverage | ${this.formatCoverageDelta(comparison.deltaBranchRate)}% |`
    );
    lines.push(
      `| Total Statements | ${this.formatDelta(comparison.deltaTotalStatements)} |`
    );
    lines.push(
      `| Covered Statements | ${this.formatDelta(comparison.deltaCoveredStatements)} |`
    );
    lines.push("");

    // Files with significant coverage changes
    const significantChanges = comparison.filesChanged.filter(
      (f) => Math.abs(f.deltaLineRate) >= 5
    );

    if (significantChanges.length > 0) {
      const improved = significantChanges.filter((f) => f.deltaLineRate > 0);
      const degraded = significantChanges.filter((f) => f.deltaLineRate < 0);

      if (degraded.length > 0) {
        lines.push(
          `#### ğŸ“‰ Files with Decreased Coverage (${degraded.length})`
        );
        lines.push("");
        lines.push("<details>");
        lines.push("<summary>View files with decreased coverage</summary>");
        lines.push("");
        lines.push("| File | Line Coverage Change | Branch Coverage Change |");
        lines.push("|------|---------------------|------------------------|");

        for (const file of degraded.slice(0, 10)) {
          const fileName = file.name.length > 40 ? `...${file.name.slice(-37)}` : file.name;
          lines.push(
            `| \`${fileName}\` | ${this.formatCoverageDelta(file.deltaLineRate)}% (${file.baseLineRate}% â†’ ${file.currentLineRate}%) | ${this.formatCoverageDelta(file.deltaBranchRate)}% |`
          );
        }

        lines.push("");
        lines.push("</details>");
        lines.push("");
      }

      if (improved.length > 0) {
        lines.push(
          `#### ğŸ“ˆ Files with Improved Coverage (${improved.length})`
        );
        lines.push("");
        lines.push("<details>");
        lines.push("<summary>View files with improved coverage</summary>");
        lines.push("");
        lines.push("| File | Line Coverage Change | Branch Coverage Change |");
        lines.push("|------|---------------------|------------------------|");

        for (const file of improved.slice(0, 10)) {
          const fileName = file.name.length > 40 ? `...${file.name.slice(-37)}` : file.name;
          lines.push(
            `| \`${fileName}\` | ${this.formatCoverageDelta(file.deltaLineRate)}% (${file.baseLineRate}% â†’ ${file.currentLineRate}%) | ${this.formatCoverageDelta(file.deltaBranchRate)}% |`
          );
        }

        lines.push("");
        lines.push("</details>");
        lines.push("");
      }
    }

    // New files
    if (comparison.filesAdded.length > 0) {
      lines.push(`#### â• New Files with Coverage (${comparison.filesAdded.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View new files</summary>");
      lines.push("");
      lines.push("| File | Line Coverage | Branch Coverage |");
      lines.push("|------|---------------|-----------------|");

      for (const file of comparison.filesAdded.slice(0, 10)) {
        const fileName = file.name.length > 40 ? `...${file.name.slice(-37)}` : file.name;
        lines.push(
          `| \`${fileName}\` | ${this.getCoverageEmoji(file.lineRate)} ${file.lineRate}% | ${this.getCoverageEmoji(file.branchRate)} ${file.branchRate}% |`
        );
      }

      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Removed files
    if (comparison.filesRemoved.length > 0) {
      lines.push(`#### â– Removed Files (${comparison.filesRemoved.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View removed files</summary>");
      lines.push("");
      for (const file of comparison.filesRemoved.slice(0, 10)) {
        lines.push(`- \`${file.name}\``);
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }
  }

  /**
   * Add comparison section to the comment
   */
  private addComparisonSection(
    lines: string[],
    comparison: TestComparison
  ): void {
    lines.push("### ğŸ“Š Comparison with Base Branch");
    lines.push("");

    // Summary table
    lines.push("| Metric | Change |");
    lines.push("|--------|--------|");
    lines.push(`| Total Tests | ${this.formatDelta(comparison.deltaTotal)} |`);
    lines.push(`| Passed Tests | ${this.formatDelta(comparison.deltaPassed)} |`);
    lines.push(`| Failed Tests | ${this.formatDelta(comparison.deltaFailed)} |`);
    lines.push(`| Skipped Tests | ${this.formatDelta(comparison.deltaSkipped)} |`);
    lines.push("");

    // Tests broken (regressions)
    if (comparison.testsBroken.length > 0) {
      lines.push(`#### ğŸ”´ Tests Broken (${comparison.testsBroken.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View broken tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsBroken) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
        if (testChange.testCase.failure) {
          lines.push(`  - **Error:** ${testChange.testCase.failure.message}`);
        }
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Tests fixed (improvements)
    if (comparison.testsFixed.length > 0) {
      lines.push(`#### ğŸŸ¢ Tests Fixed (${comparison.testsFixed.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View fixed tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsFixed) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Tests added
    if (comparison.testsAdded.length > 0) {
      lines.push(`#### â• New Tests (${comparison.testsAdded.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View new tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsAdded) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
        if (testChange.testCase.failure) {
          lines.push(`  - **Status:** âŒ Failing`);
        } else {
          lines.push(`  - **Status:** âœ… Passing`);
        }
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Tests removed
    if (comparison.testsRemoved.length > 0) {
      lines.push(`#### â– Removed Tests (${comparison.testsRemoved.length})`);
      lines.push("");
      lines.push("<details>");
      lines.push("<summary>View removed tests</summary>");
      lines.push("");
      for (const testChange of comparison.testsRemoved) {
        lines.push(`- \`${testChange.identifier.testName}\``);
        lines.push(`  - **File:** \`${testChange.identifier.classname}\``);
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Summary message
    if (
      comparison.testsBroken.length === 0 &&
      comparison.testsFixed.length === 0 &&
      comparison.testsAdded.length === 0 &&
      comparison.testsRemoved.length === 0
    ) {
      lines.push("âœ¨ No test changes detected");
      lines.push("");
    }
  }

  /**
   * Format a delta value with appropriate sign and emoji
   */
  private formatDelta(delta: number): string {
    if (delta === 0) {
      return "â€”";
    }
    const sign = delta > 0 ? "+" : "";
    const emoji = delta > 0 ? "ğŸ“ˆ" : "ğŸ“‰";
    return `${emoji} ${sign}${delta}`;
  }

  /**
   * Format a coverage delta value with appropriate sign
   */
  private formatCoverageDelta(delta: number): string {
    if (delta === 0) {
      return "Â±0.00";
    }
    const sign = delta > 0 ? "+" : "";
    return `${sign}${delta.toFixed(2)}`;
  }

  /**
   * Get emoji based on coverage percentage
   */
  private getCoverageEmoji(coverage: number): string {
    if (coverage >= 80) return "ğŸŸ¢";
    if (coverage >= 50) return "ğŸŸ¡";
    if (coverage > 0) return "ğŸ”´";
    return "âšª";
  }

  /**
   * Calculate method coverage percentage
   */
  private calculateMethodCoverage(results: AggregatedCoverageResults): number {
    if (results.totalMethods === 0) return 0;
    return Number.parseFloat(
      ((results.coveredMethods / results.totalMethods) * 100).toFixed(2)
    );
  }

  /**
   * Format execution time in a human-readable way
   */
  private formatTime(seconds: number): string {
    if (seconds < 1) {
      return `${Math.round(seconds * 1000)}ms`;
    }
    if (seconds < 60) {
      return `${seconds.toFixed(2)}s`;
    }
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
  }

  /**
   * Generate a unique identifier for the comment
   * This helps identify comments created by this action
   */
  static getCommentIdentifier(): string {
    return "<!-- codecov-action-results -->";
  }

  /**
   * Legacy identifier for backward compatibility
   */
  static getLegacyCommentIdentifier(): string {
    return "<!-- codecov-action-test-results -->";
  }

  /**
   * Add identifier to comment body
   */
  addIdentifier(comment: string): string {
    return `${PRCommentFormatter.getCommentIdentifier()}\n${comment}`;
  }
}
