import * as core from "@actions/core";
import type { AggregatedTestResults } from "../types/test-results.js";
import type { AggregatedCoverageResults } from "../types/coverage.js";

/**
 * Write test results and coverage to GitHub Actions Job Summary
 */
export async function writeJobSummary(
  testResults?: AggregatedTestResults,
  coverageResults?: AggregatedCoverageResults
): Promise<void> {
  const summary = core.summary;

  // Main header
  summary.addHeading("Codecov Action Results üìä", 1);

  // Add test results section
  if (testResults) {
    await addTestResultsSection(summary, testResults);
  }

  // Add coverage section
  if (coverageResults) {
    await addCoverageSection(summary, coverageResults);
  }

  // Footer
  summary.addRaw("\n---\n*Generated by Codecov Action*\n");

  // Write the summary
  await summary.write();
}

/**
 * Add test results section to job summary
 */
async function addTestResultsSection(
  summary: typeof core.summary,
  results: AggregatedTestResults
): Promise<void> {
  summary.addHeading("Test Results üß™", 2);

  // Summary table
  const passEmoji = results.passedTests > 0 ? "‚úÖ" : "";
  const failEmoji = results.failedTests > 0 ? "‚ùå" : "";
  const skipEmoji = results.skippedTests > 0 ? "‚è≠Ô∏è" : "";

  summary.addTable([
    [
      { data: "Metric", header: true },
      { data: "Value", header: true },
    ],
    ["Total Tests", results.totalTests.toString()],
    ["Passed", `${passEmoji} ${results.passedTests}`],
    ["Failed", `${failEmoji} ${results.failedTests}`],
    ["Skipped", `${skipEmoji} ${results.skippedTests}`],
    ["Pass Rate", `${results.passRate}%`],
    ["Execution Time", formatTime(results.totalTime)],
  ]);

  // Add comparison section if available
  if (results.comparison) {
    summary.addHeading("üìä Comparison with Base Branch", 3);

    summary.addTable([
      [
        { data: "Metric", header: true },
        { data: "Change", header: true },
      ],
      ["Total Tests", formatDelta(results.comparison.deltaTotal)],
      ["Passed Tests", formatDelta(results.comparison.deltaPassed)],
      ["Failed Tests", formatDelta(results.comparison.deltaFailed)],
      ["Skipped Tests", formatDelta(results.comparison.deltaSkipped)],
    ]);

    // Tests broken (regressions)
    if (results.comparison.testsBroken.length > 0) {
      const brokenTestsList = results.comparison.testsBroken
        .map(
          (t) =>
            `- \`${t.identifier.testName}\` (${t.identifier.classname})${t.testCase.failure ? `: ${t.testCase.failure.message}` : ""}`
        )
        .join("\n");

      summary.addDetails(
        `üî¥ Tests Broken (${results.comparison.testsBroken.length})`,
        brokenTestsList
      );
    }

    // Tests fixed
    if (results.comparison.testsFixed.length > 0) {
      const fixedTestsList = results.comparison.testsFixed
        .map((t) => `- \`${t.identifier.testName}\` (${t.identifier.classname})`)
        .join("\n");

      summary.addDetails(
        `üü¢ Tests Fixed (${results.comparison.testsFixed.length})`,
        fixedTestsList
      );
    }

    // Tests added
    if (results.comparison.testsAdded.length > 0) {
      const addedTestsList = results.comparison.testsAdded
        .map(
          (t) =>
            `- \`${t.identifier.testName}\` (${t.identifier.classname}) ${t.testCase.failure ? "‚ùå" : "‚úÖ"}`
        )
        .join("\n");

      summary.addDetails(
        `‚ûï New Tests (${results.comparison.testsAdded.length})`,
        addedTestsList
      );
    }

    // Tests removed
    if (results.comparison.testsRemoved.length > 0) {
      const removedTestsList = results.comparison.testsRemoved
        .map((t) => `- \`${t.identifier.testName}\` (${t.identifier.classname})`)
        .join("\n");

      summary.addDetails(
        `‚ûñ Removed Tests (${results.comparison.testsRemoved.length})`,
        removedTestsList
      );
    }
  }

  // Show failed tests if any
  if (results.failedTests > 0 && results.failedTestCases.length > 0) {
    summary.addHeading("‚ùå Failed Tests", 3);

    for (const { suiteName, testCase } of results.failedTestCases) {
      const testHeader = `\`${testCase.name}\``;
      let details = `**File:** \`${testCase.classname}\`\n`;

      if (suiteName && suiteName !== testCase.classname) {
        details += `**Suite:** \`${suiteName}\`\n`;
      }

      if (testCase.failure) {
        details += `**Error:** ${testCase.failure.message}\n`;

        if (testCase.failure.content) {
          details += `\n\`\`\`\n${testCase.failure.content.trim()}\n\`\`\`\n`;
        }
      }

      summary.addDetails(testHeader, details);
    }
  } else if (results.failedTests === 0) {
    summary.addRaw("\n### ‚úÖ All Tests Passed!\n\nGreat job! All tests are passing successfully.\n\n");
  }
}

/**
 * Add coverage section to job summary (clean, minimal format)
 */
async function addCoverageSection(
  summary: typeof core.summary,
  results: AggregatedCoverageResults
): Promise<void> {
  summary.addHeading("Codecov Report", 2);

  // Calculate metrics
  const totalMissing = results.totalMisses || 0;
  const coverageChange = results.comparison
    ? formatCoverageDelta(results.comparison.deltaLineRate)
    : null;

  // Single line summary
  const parts: string[] = [`Coverage: **${results.lineRate}%**`];
  if (coverageChange) {
    parts[0] += ` (${coverageChange}%)`;
  }
  if (totalMissing > 0) {
    parts.push(`${totalMissing} lines missing`);
  }
  if (results.comparison) {
    const baseRef = results.comparison.baseCommit
      ? `\`${results.comparison.baseCommit.substring(0, 7)}\``
      : "`base`";
    const headRef = results.comparison.headCommit
      ? `\`${results.comparison.headCommit.substring(0, 7)}\``
      : "`head`";
    parts.push(`Comparing ${baseRef} to ${headRef}`);
  }

  summary.addRaw(`\n${parts.join(" | ")}\n\n`);

  // Files with missing lines (all in collapsed section)
  const filesWithMissing = results.files
    .filter((f) => (f.missingLines?.length || 0) > 0 || (f.partialLines?.length || 0) > 0)
    .sort((a, b) => {
      const aMissing = (a.missingLines?.length || 0) + (a.partialLines?.length || 0);
      const bMissing = (b.missingLines?.length || 0) + (b.partialLines?.length || 0);
      return bMissing - aMissing;
    });

  if (filesWithMissing.length > 0) {
    // Build markdown table for files
    const fileRows = filesWithMissing.map((file) => {
      const fileName = getFileName(file.path);
      const missingCount = file.missingLines?.length || 0;
      const partialCount = file.partialLines?.length || 0;

      let linesText = "";
      if (missingCount > 0 && partialCount > 0) {
        linesText = `${missingCount} missing, ${partialCount} partial`;
      } else if (missingCount > 0) {
        linesText = `${missingCount} missing`;
      } else if (partialCount > 0) {
        linesText = `${partialCount} partial`;
      }

      return `| \`${fileName}\` | ${file.lineRate.toFixed(2)}% | ${linesText} |`;
    });

    const filesTable = `| File | Coverage | Missing |\n|------|----------|--------|\n${fileRows.join("\n")}`;
    summary.addDetails(
      `Files with missing lines (${filesWithMissing.length} files)`,
      filesTable
    );
  }

  // Coverage diff table (using addTable for proper rendering)
  if (results.comparison) {
    const comparison = results.comparison;
    const baseBranch = comparison.baseBranch || "base";

    const diffTableData: Array<Array<string | { data: string; header: boolean }>> = [
      [
        { data: "Metric", header: true },
        { data: baseBranch, header: true },
        { data: "PR", header: true },
        { data: "+/-", header: true },
      ],
      [
        "Coverage",
        `${(results.lineRate - comparison.deltaLineRate).toFixed(2)}%`,
        `${results.lineRate}%`,
        `${formatCoverageDelta(comparison.deltaLineRate)}%`,
      ],
      [
        "Lines",
        `${comparison.baseLines || 0}`,
        `${comparison.currentLines || 0}`,
        formatDeltaSimple(comparison.deltaLines || 0),
      ],
      [
        "Hits",
        `${comparison.baseHits || 0}`,
        `${comparison.currentHits || 0}`,
        formatDeltaSimple(comparison.deltaHits || 0),
      ],
      [
        "Misses",
        `${comparison.baseMisses || 0}`,
        `${comparison.currentMisses || 0}`,
        formatDeltaSimple(comparison.deltaMisses || 0),
      ],
    ];

    // Only add partials row if there are any
    if ((comparison.basePartials || 0) > 0 || (comparison.currentPartials || 0) > 0) {
      diffTableData.push([
        "Partials",
        `${comparison.basePartials || 0}`,
        `${comparison.currentPartials || 0}`,
        formatDeltaSimple(comparison.deltaPartials || 0),
      ]);
    }

    // Build the table HTML manually for details section
    const tableRows = diffTableData
      .map((row, i) => {
        if (i === 0) {
          return `| ${row.map((c) => (typeof c === "object" ? `**${c.data}**` : c)).join(" | ")} |`;
        }
        return `| ${row.join(" | ")} |`;
      })
      .join("\n");

    const tableHeader = "| Metric | " + baseBranch + " | PR | +/- |\n|--------|------|-----|-----|";
    const tableBody = diffTableData
      .slice(1)
      .map((row) => `| ${row.join(" | ")} |`)
      .join("\n");

    summary.addDetails("Coverage diff", `${tableHeader}\n${tableBody}`);
  }

  // Flags section (only if flags exist)
  if (results.flags && results.flags.length > 0) {
    const flagsList = results.flags
      .map((flag) => {
        const change = results.comparison
          ? ` (${formatCoverageDelta(results.comparison.deltaLineRate)}%)`
          : "";
        return `- \`${flag}\`: ${results.lineRate}%${change}`;
      })
      .join("\n");

    summary.addDetails(`Flags (${results.flags.length})`, flagsList);
  }
}

/**
 * Get just the filename from a path
 */
function getFileName(path: string): string {
  return path.split("/").pop() || path;
}

/**
 * Format delta value with sign only (no emoji)
 */
function formatDeltaSimple(delta: number): string {
  if (delta === 0) return "‚Äî";
  const sign = delta > 0 ? "+" : "";
  return `${sign}${delta}`;
}

/**
 * Format a delta value with appropriate sign and emoji
 */
function formatDelta(delta: number): string {
  if (delta === 0) {
    return "‚Äî";
  }
  const sign = delta > 0 ? "+" : "";
  const emoji = delta > 0 ? "üìà" : "üìâ";
  return `${emoji} ${sign}${delta}`;
}

/**
 * Format a coverage delta value with appropriate sign
 */
function formatCoverageDelta(delta: number): string {
  if (delta === 0) {
    return "¬±0.00";
  }
  const sign = delta > 0 ? "+" : "";
  return `${sign}${delta.toFixed(2)}`;
}

/**
 * Format execution time in a human-readable way
 */
function formatTime(seconds: number): string {
  if (seconds < 1) {
    return `${Math.round(seconds * 1000)}ms`;
  }
  if (seconds < 60) {
    return `${seconds.toFixed(2)}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
}

