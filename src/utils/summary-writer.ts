import * as core from "@actions/core";
import type { AggregatedTestResults } from "../types/test-results.js";
import type { AggregatedCoverageResults } from "../types/coverage.js";

/**
 * Write test results and coverage to GitHub Actions Job Summary
 */
export async function writeJobSummary(
  testResults?: AggregatedTestResults,
  coverageResults?: AggregatedCoverageResults
): Promise<void> {
  const summary = core.summary;

  // Main header
  summary.addHeading("Codecov Action Results üìä", 1);

  // Add test results section
  if (testResults) {
    await addTestResultsSection(summary, testResults);
  }

  // Add coverage section
  if (coverageResults) {
    await addCoverageSection(summary, coverageResults);
  }

  // Footer
  summary.addRaw("\n---\n*Generated by Codecov Action*\n");

  // Write the summary
  await summary.write();
}

/**
 * Add test results section to job summary
 */
async function addTestResultsSection(
  summary: typeof core.summary,
  results: AggregatedTestResults
): Promise<void> {
  summary.addHeading("Test Results üß™", 2);

  // Summary table
  const passEmoji = results.passedTests > 0 ? "‚úÖ" : "";
  const failEmoji = results.failedTests > 0 ? "‚ùå" : "";
  const skipEmoji = results.skippedTests > 0 ? "‚è≠Ô∏è" : "";

  summary.addTable([
    [
      { data: "Metric", header: true },
      { data: "Value", header: true },
    ],
    ["Total Tests", results.totalTests.toString()],
    ["Passed", `${passEmoji} ${results.passedTests}`],
    ["Failed", `${failEmoji} ${results.failedTests}`],
    ["Skipped", `${skipEmoji} ${results.skippedTests}`],
    ["Pass Rate", `${results.passRate}%`],
    ["Execution Time", formatTime(results.totalTime)],
  ]);

  // Add comparison section if available
  if (results.comparison) {
    summary.addHeading("üìä Comparison with Base Branch", 3);

    summary.addTable([
      [
        { data: "Metric", header: true },
        { data: "Change", header: true },
      ],
      ["Total Tests", formatDelta(results.comparison.deltaTotal)],
      ["Passed Tests", formatDelta(results.comparison.deltaPassed)],
      ["Failed Tests", formatDelta(results.comparison.deltaFailed)],
      ["Skipped Tests", formatDelta(results.comparison.deltaSkipped)],
    ]);

    // Tests broken (regressions)
    if (results.comparison.testsBroken.length > 0) {
      const brokenTestsList = results.comparison.testsBroken
        .map(
          (t) =>
            `- \`${t.identifier.testName}\` (${t.identifier.classname})${t.testCase.failure ? `: ${t.testCase.failure.message}` : ""}`
        )
        .join("\n");

      summary.addDetails(
        `üî¥ Tests Broken (${results.comparison.testsBroken.length})`,
        brokenTestsList
      );
    }

    // Tests fixed
    if (results.comparison.testsFixed.length > 0) {
      const fixedTestsList = results.comparison.testsFixed
        .map((t) => `- \`${t.identifier.testName}\` (${t.identifier.classname})`)
        .join("\n");

      summary.addDetails(
        `üü¢ Tests Fixed (${results.comparison.testsFixed.length})`,
        fixedTestsList
      );
    }

    // Tests added
    if (results.comparison.testsAdded.length > 0) {
      const addedTestsList = results.comparison.testsAdded
        .map(
          (t) =>
            `- \`${t.identifier.testName}\` (${t.identifier.classname}) ${t.testCase.failure ? "‚ùå" : "‚úÖ"}`
        )
        .join("\n");

      summary.addDetails(
        `‚ûï New Tests (${results.comparison.testsAdded.length})`,
        addedTestsList
      );
    }

    // Tests removed
    if (results.comparison.testsRemoved.length > 0) {
      const removedTestsList = results.comparison.testsRemoved
        .map((t) => `- \`${t.identifier.testName}\` (${t.identifier.classname})`)
        .join("\n");

      summary.addDetails(
        `‚ûñ Removed Tests (${results.comparison.testsRemoved.length})`,
        removedTestsList
      );
    }
  }

  // Show failed tests if any
  if (results.failedTests > 0 && results.failedTestCases.length > 0) {
    summary.addHeading("‚ùå Failed Tests", 3);

    for (const { suiteName, testCase } of results.failedTestCases) {
      const testHeader = `\`${testCase.name}\``;
      let details = `**File:** \`${testCase.classname}\`\n`;

      if (suiteName && suiteName !== testCase.classname) {
        details += `**Suite:** \`${suiteName}\`\n`;
      }

      if (testCase.failure) {
        details += `**Error:** ${testCase.failure.message}\n`;

        if (testCase.failure.content) {
          details += `\n\`\`\`\n${testCase.failure.content.trim()}\n\`\`\`\n`;
        }
      }

      summary.addDetails(testHeader, details);
    }
  } else if (results.failedTests === 0) {
    summary.addRaw("\n### ‚úÖ All Tests Passed!\n\nGreat job! All tests are passing successfully.\n\n");
  }
}

/**
 * Add coverage section to job summary (Codecov-style format)
 */
async function addCoverageSection(
  summary: typeof core.summary,
  results: AggregatedCoverageResults
): Promise<void> {
  summary.addHeading("Codecov Report", 2);

  // Calculate total missing lines
  const totalMissing = results.totalMisses || 0;

  // Header summary with patch coverage
  const coverageEmoji = results.lineRate >= 80 ? "‚úÖ" : "‚ùå";
  if (totalMissing > 0) {
    summary.addRaw(
      `\n‚ùå Patch coverage is **${results.lineRate}%** with **${totalMissing} lines** missing coverage.\n`
    );
  } else {
    summary.addRaw(`\n${coverageEmoji} Project coverage is **${results.lineRate}%**.\n`);
  }

  // Comparison info
  if (results.comparison) {
    const baseCommit = results.comparison.baseCommit
      ? results.comparison.baseCommit.substring(0, 7)
      : "base";
    const headCommit = results.comparison.headCommit
      ? results.comparison.headCommit.substring(0, 7)
      : "head";
    const improvementEmoji = results.comparison.improvement
      ? "‚úÖ"
      : results.comparison.deltaLineRate < 0
        ? "‚ùå"
        : "‚úÖ";
    summary.addRaw(
      `${improvementEmoji} Project coverage is **${results.lineRate}%**. Comparing base (\`${baseCommit}\`) to head (\`${headCommit}\`).\n\n`
    );
  }

  // Files with missing lines table
  const filesWithMissing = results.files
    .filter((f) => (f.missingLines?.length || 0) > 0 || (f.partialLines?.length || 0) > 0)
    .sort((a, b) => {
      const aMissing = (a.missingLines?.length || 0) + (a.partialLines?.length || 0);
      const bMissing = (b.missingLines?.length || 0) + (b.partialLines?.length || 0);
      return bMissing - aMissing;
    });

  if (filesWithMissing.length > 0) {
    summary.addHeading("Files with missing lines", 3);

    const tableData: Array<Array<string | { data: string; header: boolean }>> = [
      [
        { data: "File", header: true },
        { data: "Patch %", header: true },
        { data: "Lines", header: true },
      ],
    ];

    for (const file of filesWithMissing.slice(0, 15)) {
      const fileName = truncateFileName(file.path, 60);
      const missingCount = file.missingLines?.length || 0;
      const partialCount = file.partialLines?.length || 0;

      let linesText = "";
      if (missingCount > 0 && partialCount > 0) {
        linesText = `‚ö†Ô∏è ${missingCount} Missing and ${partialCount} partials`;
      } else if (missingCount > 0) {
        linesText = `‚ö†Ô∏è ${missingCount} Missing`;
      } else if (partialCount > 0) {
        linesText = `‚ö†Ô∏è ${partialCount} partials`;
      }

      tableData.push([`\`${fileName}\``, `${file.lineRate.toFixed(2)}%`, linesText]);
    }

    summary.addTable(tableData);

    if (filesWithMissing.length > 15) {
      summary.addRaw(`\n...and ${filesWithMissing.length - 15} more files\n`);
    }
  }

  // Additional details section
  if (results.comparison) {
    const comparison = results.comparison;
    const baseBranch = comparison.baseBranch || "main";

    const diffTable = `
| | Coverage | Diff | |
|---|---|---|---|
| | ${baseBranch} | #PR | +/- |
| **Coverage** | ${(results.lineRate - comparison.deltaLineRate).toFixed(2)}% | ${results.lineRate}% | ${formatCoverageDelta(comparison.deltaLineRate)}% |
| Files | ${comparison.baseFiles || 0} | ${comparison.currentFiles || 0} | ${formatDeltaSimple(comparison.deltaFiles || 0)} |
| Lines | ${comparison.baseLines || 0} | ${comparison.currentLines || 0} | ${formatDeltaSimple(comparison.deltaLines || 0)} |
| Branches | ${comparison.baseBranches || 0} | ${comparison.currentBranches || 0} | ${formatDeltaSimple(comparison.deltaBranches || 0)} |
| + Hits | ${comparison.baseHits || 0} | ${comparison.currentHits || 0} | ${formatDeltaSimple(comparison.deltaHits || 0)} |
| - Misses | ${comparison.baseMisses || 0} | ${comparison.currentMisses || 0} | ${formatDeltaSimple(comparison.deltaMisses || 0)} |
| - Partials | ${comparison.basePartials || 0} | ${comparison.currentPartials || 0} | ${formatDeltaSimple(comparison.deltaPartials || 0)} |
`;

    summary.addDetails("Additional details and impacted files", diffTable);
  }

  // Flags section
  if (results.flags && results.flags.length > 0) {
    summary.addHeading("Flags", 3);

    const flagsTable: Array<Array<string | { data: string; header: boolean }>> = [
      [
        { data: "Flag", header: true },
        { data: "Coverage Œî", header: true },
      ],
    ];

    for (const flag of results.flags) {
      const coverageChange = results.comparison
        ? formatCoverageDelta(results.comparison.deltaLineRate)
        : "‚Äî";
      flagsTable.push([`\`${flag}\``, `${results.lineRate}% (${coverageChange}%)`]);
    }

    summary.addTable(flagsTable);
  }
}

/**
 * Truncate file name for display
 */
function truncateFileName(path: string, maxLength: number): string {
  if (path.length <= maxLength) return path;
  return `...${path.slice(-(maxLength - 3))}`;
}

/**
 * Format delta value with sign only (no emoji)
 */
function formatDeltaSimple(delta: number): string {
  if (delta === 0) return "‚Äî";
  const sign = delta > 0 ? "+" : "";
  return `${sign}${delta}`;
}

/**
 * Format a delta value with appropriate sign and emoji
 */
function formatDelta(delta: number): string {
  if (delta === 0) {
    return "‚Äî";
  }
  const sign = delta > 0 ? "+" : "";
  const emoji = delta > 0 ? "üìà" : "üìâ";
  return `${emoji} ${sign}${delta}`;
}

/**
 * Format a coverage delta value with appropriate sign
 */
function formatCoverageDelta(delta: number): string {
  if (delta === 0) {
    return "¬±0.00";
  }
  const sign = delta > 0 ? "+" : "";
  return `${sign}${delta.toFixed(2)}`;
}

/**
 * Get emoji based on coverage percentage
 */
function getCoverageEmoji(coverage: number): string {
  if (coverage >= 80) return "üü¢";
  if (coverage >= 50) return "üü°";
  if (coverage > 0) return "üî¥";
  return "‚ö™";
}

/**
 * Format execution time in a human-readable way
 */
function formatTime(seconds: number): string {
  if (seconds < 1) {
    return `${Math.round(seconds * 1000)}ms`;
  }
  if (seconds < 60) {
    return `${seconds.toFixed(2)}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
}

